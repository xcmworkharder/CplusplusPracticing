//
// Created by xcmworkharder on 2020-09-01 下午9:43.
//
#include <iostream>
#include <vector>

using namespace std;

/// 异常安全的代码，可以没有任何try和catch,异常安全是指当异常发生时，不会发生内存泄露，系统也不会处于一个不一致状态

/// c++17开始 已经完全禁止了以往的动态异常规约，唯一能声明的就是函数不会抛出异常 noexcept noexcept(true) throw等
/// 如果声明不会抛出异常，结果却抛出了，则会直接调用std::terminate来终止程序。
/// 泛型编程中，不能预知的异常太多了。

/// 1.写异常安全的代码，尤其在模板中，提供强异常安全保证，在任何第三方代码发生异常的的情况下，不改变异常的内容，也不产生任何资源泄露
/// 2.如果可能会抛出异常，在文档中明确可能发生异常的类型和发生条件，确保使用你代码的人，能在不检查你的实现的情况下，了解需要准备处理那些异常。
/// 3.对于确定不会抛出异常的代码，标记为noexcpet, 构造、析构、赋值函数等会自动成为noexcept,如果调用她们的代码都是noexcept的话，也进行noexcept标记。

/// vector在接收没有异常安全保证的元素时，会使用拷贝构造函数，而不使用移动构造函数，因为一旦某个操作发生了异常，被移动的元素会被破坏，处于只能析构的的状态，异常安全性无法保证了。
/// 如果使用了标准容器，不管自己用不用异常，都要处理标准容器可能发生的异常（至少有bad_alloc),但linux不会产生这个异常。

/// 对于运行时的错误可以使用异常，也可以使用assert,在调试环境中报告错误并终止程序运行。但是测试通常不会覆盖所有代码和分之，assert在发布模式下被禁用，两者并不是完全的替代关系。
/// 在允许异常的情况下，异常可以获得调试和发布模式都良好、一致的效果。
void testVectorOutOfRange() {
    vector<int> vec {1, 3, 2, 1, 4};

    try {
        int test = vec.at(6);
    } catch (const out_of_range& e) {
        cerr << e.what() << endl;
    }
}

int main() {

    testVectorOutOfRange();

    return 0;
}
